<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>搭建博客踩坑指南</title>
    <url>/2022/05/06/%E5%8D%9A%E5%AE%A2%E8%B8%A9%E5%9D%91/</url>
    <content><![CDATA[<h1 id="愉快踩坑之旅"><a href="#愉快踩坑之旅" class="headerlink" title="愉快踩坑之旅"></a>愉快踩坑之旅</h1><h2 id="搭建过程之中的踩坑之路"><a href="#搭建过程之中的踩坑之路" class="headerlink" title="搭建过程之中的踩坑之路"></a>搭建过程之中的踩坑之路</h2><ul>
<li>tips: 本文所有的搭建以及运营博文的平台均为Linux</li>
<li>坑1：在本地已经完成搭建之后，涉及到后续将本地的博客链接到github上此时就会有问题。<br>(1) 当出现无法链接到github，并报2021年开始取消了ssh链接，此时需要使用个人令牌访问github<br>解决方法：在自己的github settings里面找到自己的个人令牌，并按照自己的需求申请所需要的设定令牌的基本的可以使用的时间，建议可以对于自己的博客申请永久，并再<strong>hexo d</strong>之后要求输入自己的github帐号密码的时候，直接在密码的地方键入你的个人令牌。  </li>
<li>申请个人令牌的流程: settings-&gt; Developer settings -&gt; Personal access token</li>
<li>坑2：由于众所周知的原因在推送到github上的时候，有很多时候<strong>hexo d</strong>会出现超时的问题</li>
<li>解决方法，修改设置里面的**_config.yml**文件，一定注意不是主题里面的设置文件，而是你的博客里面的根目录里面的设置文件。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将你的仓库的地址修改为如下所示的格式，别用https</span><br><span class="line"></span><br><span class="line">git@github.com:YOURNAME/YOURNAME.github.io.git</span><br><span class="line"></span><br><span class="line">//只用将YOURNAME修改为你自己的github帐号的名字即可</span><br></pre></td></tr></table></figure></li>
<li>坑3(其实也可以说是强迫症需要改)</li>
<li>有时候在你<strong>hexo g</strong>之后，可能会出现一堆的warnning，其实警告没多大影响，就是出现几个警告感觉有点难看，随需要更改,相关的警告如下图所示  </li>
<li>很明显，就是node.js出了问题，在使用node -v查看node.js的版本的时候，发现版本是16的版本，就是版本太高了,eg: n v12.28.20 命令可以将node.js的版本降低到你所要的版本即可。<h2 id="主题魔改之路"><a href="#主题魔改之路" class="headerlink" title="主题魔改之路"></a>主题魔改之路</h2></li>
<li>关于修改配置文件的问题<br><strong>别在</strong>原始的配置文件之中修改，出了问题很难再去改，重新建一个**_config.butterfly.yml<strong>文件，把</strong>butterfly** 主题里面的文件复制过来，并放在博客的根目录<br>Linux下拷贝文件到指定的目录的命令如下<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp xxx.yml /home/dcx/blog  #打开所在文件的terminal，并把你想要拷贝的文件xxx移到你想要的目录</span><br></pre></td></tr></table></figure></li>
<li>关于在menu里面修改的问题<br>一定记得，在将menu改为中文之后，并去除#之后，&#x2F;和||之间的空格一定要去除，此时才能呢个访问到指定的界面，否则会报错。如下图的更改格式  </li>
<li>建议不懂前端的，可以没必要把时间浪费在上面，博客是拿来更新的，拿来写的，记录了你的日常的，所以可以直接在根目录中你创建的<strong>yml</strong>文件之中修改，这样即使改错了，也能在后面拿原来的配置文件来修改。推荐几个好用的链接。</li>
<li><a href="https://butterfly.js.org/">一个好用的博客</a><br>我主要是在这里面按照其教程修改自己的博客，在此表示感谢！</li>
<li><a href="https://sm.ms/">一个好用的图床</a><br>在本地弄图片太麻烦了，使用这个图床吧，免费好使</li>
<li><strong>END</strong></li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo, 踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>cvlab1</title>
    <url>/2022/05/09/cvlab1/</url>
    <content><![CDATA[<h1 id="24位BMP图片转换为灰度图-C语言实现"><a href="#24位BMP图片转换为灰度图-C语言实现" class="headerlink" title="24位BMP图片转换为灰度图(C语言实现)"></a>24位BMP图片转换为灰度图(C语言实现)</h1><h2 id="BMP图格式"><a href="#BMP图格式" class="headerlink" title="BMP图格式"></a>BMP图格式</h2><ul>
<li>BMP格式的文件从文件头到文件尾的信息依次如下所示:<br>(1) bmp文件头:14字节，提供文件的格式，大小等信息。<br>(2) 位图信息头:40字节，文件的尺寸，位平面数，压缩方式，颜色索引等信息<br>(3) 调色板:可以选择的部分，当使用索引来表示信息的时候，索引所对应的就是与其颜色的映射表。<br>(4) 位图数据: 图像数据区<h2 id="灰度转换公式"><a href="#灰度转换公式" class="headerlink" title="灰度转换公式"></a>灰度转换公式</h2></li>
<li><strong>attention</strong>:bmp图片在整个计算机内部所存的像素的信息是按照blue,green,red的形式存放的  </li>
<li>几个灰度转换公式<br>(1) $$gray&#x3D;red 0.229 +green 0.587 +blue 0.114 $$ 在使用的时候可以用整数除法代替，变换之后的公式就是乘一个1000，再除以一个1000<br>(2) 平均值法:$$gray&#x3D;(red+green+blue)&#x2F;3$$<br>最主要的灰度转换公式最大的区别就在于实现的效果之间存在差异</li>
</ul>
<h2 id="实现方法一：简单方法-C语言实现"><a href="#实现方法一：简单方法-C语言实现" class="headerlink" title="实现方法一：简单方法(C语言实现)"></a>实现方法一：简单方法(C语言实现)</h2><ul>
<li>实现的主要的方法就在于弄懂bmp在计算机里面是如何存储的，特别是针对24位的bmp图片，在24位bmp图片之中是没有调色板的，所以在前面54字节有关bmp图像的一些格式之后，之后的信息都是位图数据，也就是每一个像素点的信息，同时每一个像素点占<strong>1字节</strong>，巧的是char类型也占<strong>1字节</strong>，所以就可以直接用一个buff存前面54字节的位图信息，后面打开文件的指针所指向的内容就是整个位图的信息，就可以开始根据灰度转换公式进行改变。</li>
<li>实现过程之中一些注意事项和主要所用的函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//血泪教训，读入文件时候一定要读成二进制文件，找了几次bug都没找到这个问题</span></span><br><span class="line"><span class="built_in">fopen</span>(<span class="string">&quot;txt&quot;</span>,<span class="string">&quot;rb&quot;</span>); <span class="comment">//读文件，后面rb一定要加b！！不然铁定在后面要出错，写文件同理</span></span><br><span class="line"><span class="built_in">ftell</span>(FIEL *stream); <span class="comment">//记录文件指针所移动的距离，由于bmp的每个像素点都是一字节，所以完全可以用指针移动的距离来判断文件长度</span></span><br><span class="line"><span class="built_in">fseek</span>(FILE *stream ,<span class="type">int</span> offset,<span class="type">int</span> fromwhere);<span class="comment">//fromwhere: SEEK_SET：文件开头,SEEK_CUR：目前所读位置,SEEK_END：文件尾</span></span><br><span class="line"><span class="built_in">fseek</span>(stream,<span class="number">0</span>,SEEK_END);<span class="comment">//直接到文件尾部</span></span><br></pre></td></tr></table></figure></li>
<li>用好C语言的几个文件处理的函数即可，注意读入文件为二进制文件即可，之后在灰度转换时候直接利用灰度转换公式即可。<h2 id="实现方法二：利用bmp图像格式"><a href="#实现方法二：利用bmp图像格式" class="headerlink" title="实现方法二：利用bmp图像格式"></a>实现方法二：利用bmp图像格式</h2></li>
<li>我们已经通过前面的内容知道BMP图像的格式是由四个部分所组成，分别为<strong>位图文件头</strong>，<strong>位图信息头</strong>，<strong>调色板</strong>，<strong>位图数据</strong>，而在整个彩色图转灰度图的过程之中，最重要的内容就是位图数据，特别是对于24位的bmp图来说，他是没有调色板的，所以一切的可以需要更改的内容都在位图数据上，那么就考虑利用结构体来表示整个bmp的图像的格式。  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagBITMAPFILEHEADER</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> bfType[<span class="number">2</span>];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bfSize;</span><br><span class="line">  <span class="comment">//两个保留字</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> bfReserved1;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> bfReserved2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> bfOffBits;<span class="comment">//偏移量</span></span><br><span class="line"></span><br><span class="line">&#125;fileHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagBITMAPINFOHEADER</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> biSize;</span><br><span class="line">  <span class="type">long</span> biWidth;</span><br><span class="line">  <span class="type">long</span> biHeight;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> biPlanes;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> biBitCount;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> biCompression;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> biSizeImage;</span><br><span class="line">  <span class="type">long</span> biXPixPerMeter;</span><br><span class="line">  <span class="type">long</span> biYPixPerMeter;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> biClrUsed;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> biClrImporant;</span><br><span class="line">&#125;fileInfo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调色板，24位的图没有调色板</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagRGBQUAD</span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> rgbBlue;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> rgbGreen;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> rgbRed;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> rgbReserved;</span><br><span class="line">&#125;rgbq;</span><br></pre></td></tr></table></figure></li>
<li>注意一个点，在使用结构体来表示bmp图的格式的时候，一定要注意<strong>内存对齐</strong>问题！！！因为计算机为了保证cpu在访存的时候效率，即若没有内存对齐，cpu在访存的时候，访问一条数据，可能会多次访存，所以结构体在定义的时候，如果没要求内存对齐，就会按照默认的形式对齐。这时候问题就会出来了，如果没有设置内存对齐，此时，在读取位图数据放在结构体的时候，就会出现在读取数据的时候，位图数据由于内存对齐的问题，造成有0填充，所以必须设置内存对齐<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#pragma pack(1)   //设置内存不对齐，这时候位图的数据就是连续存放的</span><br></pre></td></tr></table></figure></li>
<li>之后的任务就是按照读入bmp图像，并按照结构体有关定义处理相对应的数据即可。<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2></li>
<li><img src="https://s2.loli.net/2022/05/09/XheswFD6Pv9t1aI.png"></li>
<li>两种实现方法的相关的对比<br><img src="https://s2.loli.net/2022/05/09/OMRUEIn4z2VjPTG.jpg"><br>根据二者之间的bmp大小的对比，可以看到的是，在这里面，方法一由于就是简单粗暴的对所有的像素点遍历之后求解，所以他的大小和原文件的大小是一致的，而方法二的大小就不是一致的。</li>
</ul>
]]></content>
      <categories>
        <category>lab</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
</search>
